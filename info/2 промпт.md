**Objective:** Enhance the Telegram bot by integrating a memory system ("Hooks"). This system will use the Gemini 1.5 Flash model with Function Calling to analyze user messages and automatically manage facts about the user in a SQLite database via SQLAlchemy.

**Execute the following modifications and additions to the project structure:**

**Task 1: Update Project Configuration**

1.  **Modify `requirements.txt`:** Add the `google-generativeai` library.
2.  **Modify `.env` file structure:** Ensure the file includes the following keys. The values will be provided externally.
    ```env
    TELEGRAM_BOT_TOKEN='YOUR_TOKEN_HERE'
    GEMINI_API_KEY='YOUR_GEMINI_KEY_HERE'
    ```

**Task 2: Update Database Models**

**File:** `app/database/models.py`

1.  **Import necessary components:**
    ```python
    from sqlalchemy import BigInteger, String, ForeignKey, func, TIMESTAMP
    from sqlalchemy.orm import Mapped, mapped_column, relationship, declarative_base
    ```
2.  **Define `Base`:**
    ```python
    Base = declarative_base()
    ```
3.  **Update `User` Model:**
    *   Add a `relationship` to the `Hook` model. This relationship should enable loading hooks when a user object is accessed.
    *   The final model should look like this:
    ```python
    class User(Base):
        __tablename__ = 'users'
        user_id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
        username: Mapped[str] = mapped_column(String, nullable=True)
        first_name: Mapped[str] = mapped_column(String)
        created_at: Mapped[str] = mapped_column(TIMESTAMP, server_default=func.now())
        
        hooks: Mapped[list["Hook"]] = relationship(back_populates="user", cascade="all, delete-orphan")
    ```

4.  **Create `Hook` Model:**
    *   Define a new class `Hook` that inherits from `Base`.
    *   The model must contain `id`, `user_id` (as a foreign key), `text`, and `created_at`.
    *   It must have a `relationship` back to the `User` model.
    *   The final model should look like this:
    ```python
    class Hook(Base):
        __tablename__ = 'hooks'
        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
        user_id: Mapped[int] = mapped_column(ForeignKey('users.user_id'))
        text: Mapped[str] = mapped_column(String, nullable=False)
        created_at: Mapped[str] = mapped_column(TIMESTAMP, server_default=func.now())

        user: Mapped["User"] = relationship(back_populates="hooks")
    ```

**Task 3: Create Gemini Service Layer**

**File:** `app/services/gemini_service.py` (Create this new file)

1.  **Implement the following logic:**
    *   Import `os`, `google.generativeai as genai`, and `google.generativeai.types`.
    *   Configure the `genai` client using the `GEMINI_API_KEY` from `os.getenv`.
    *   Define the Gemini Tool for memory management. The function declaration must be named `manage_user_memory_hooks`.
    *   Create an asynchronous function `analyze_and_manage_hooks` that takes a user message and a list of existing hooks, calls the Gemini API with the tool, and returns the tool call result.

2.  **Provide the complete code for `gemini_service.py` as follows:**

    ```python
    import os
    import google.generativeai as genai
    from google.generativeai.types import GenerationConfig, Tool

    # --- Gemini API Configuration ---
    genai.configure(api_key=os.getenv('GEMINI_API_KEY'))

    # --- Tool Definition for Function Calling ---
    MANAGE_HOOKS_TOOL = Tool(
        function_declarations=[
            {
                "name": "manage_user_memory_hooks",
                "description": "Добавляет, обновляет или удаляет факты (хуки) о пользователе на основе анализа сообщения. Используется для поддержания актуальной информации о пользователе.",
                "parameters": {
                    "type": "OBJECT",
                    "properties": {
                        "hooks_to_add": {
                            "type": "ARRAY",
                            "items": {"type": "STRING"},
                            "description": "Список новых фактов о пользователе, которые нужно запомнить."
                        },
                        "hooks_to_update": {
                            "type": "ARRAY",
                            "items": {
                                "type": "OBJECT",
                                "properties": {
                                    "old_hook_text": {"type": "STRING"},
                                    "new_hook_text": {"type": "STRING"}
                                },
                                "required": ["old_hook_text", "new_hook_text"]
                            },
                            "description": "Список фактов для обновления. Указывает старый текст и новый текст."
                        },
                        "hooks_to_delete": {
                            "type": "ARRAY",
                            "items": {"type": "STRING"},
                            "description": "Список фактов, которые стали неактуальны и их нужно удалить."
                        }
                    }
                }
            }
        ]
    )

    # --- Gemini Model Initialization ---
    model = genai.GenerativeModel(
        model_name="gemini-1.5-flash-latest",
        tools=[MANAGE_HOOKS_TOOL]
    )

    # --- Main Analysis Function ---
    async def analyze_and_manage_hooks(message_text: str, existing_hooks: list[str]) -> genai.types.FunctionCall | None:
        """
        Analyzes user message and decides whether to call the memory management function.
        """
        system_prompt = (
            "Ты — ядро памяти умного ассистента. Твоя задача — анализировать сообщение пользователя в контексте "
            "фактов, которые ты уже знаешь о нём (`existing_hooks`). На основе нового сообщения решай, нужно ли "
            "добавить, обновить или удалить какие-либо факты, чтобы профиль пользователя был актуальным. "
            "Вызывай функцию `manage_user_memory_hooks` для выполнения этих действий. "
            "Не вызывай функцию, если сообщение является простым вопросом, общей командой или не содержит "
            "новой или обновленной личной информации, которую стоит запомнить. "
            "Пример: из сообщения 'Какой выбрать корм для стерилизованного кота 1.5 года?' извлеки три факта: 'У пользователя есть кот', 'Кот стерилизован', 'Коту 1.5 года'."
            f"Вот известные на данный момент факты о пользователе: {existing_hooks}"
        )
        
        try:
            response = await model.generate_content_async(
                system_prompt + "\n\nНовое сообщение от пользователя: " + message_text,
                generation_config=GenerationConfig(temperature=0.1)
            )
            
            if response.candidates and response.candidates[0].content.parts:
                part = response.candidates[0].content.parts[0]
                if part.function_call:
                    return part.function_call
        except Exception as e:
            print(f"Error during Gemini API call: {e}")
            return None
        
        return None
    ```

**Task 4: Update Message Handlers**

**File:** `app/handlers/user_commands.py`

1.  **Import necessary components:** `F`, `Message`, `select`, `delete`, `update`. Import `AsyncSession`, `User`, `Hook`. Import `analyze_and_manage_hooks` service.
2.  **Create a new message handler:** This handler must trigger for any text message that is not a command (`F.text & ~F.text.startswith('/')`).
3.  **Implement the handler logic:**
    *   Get `AsyncSession` from middleware or context.
    *   Query the database to get the user and their existing hooks using a `select` statement with `options(selectinload(User.hooks))`.
    *   Call `analyze_and_manage_hooks` with the message text and the list of current hook texts.
    *   If the service returns a `FunctionCall`:
        *   Extract the arguments: `hooks_to_add`, `hooks_to_update`, `hooks_to_delete`.
        *   **Add new hooks:** Iterate through `hooks_to_add` and create new `Hook` objects, associating them with the user.
        *   **Delete hooks:** Iterate through `hooks_to_delete` and delete them from the database.
        *   **Update hooks:** Iterate through `hooks_to_update` and update the text of existing hooks.
        *   Commit the session.
    *   The handler should not send any reply to the user.

**Task 5: Ensure Database Initialization**

**File:** `app/bot.py`

1.  Verify that the `main` function calls the asynchronous function responsible for `Base.metadata.create_all(engine)` before starting the bot polling. This ensures the new `hooks` table is created.